{"ast":null,"code":"// src/components/admin/utils/editorUtils.js\n\n/**\n * Inserta sintaxis de markdown en el texto de acuerdo al tipo especificado\n * \n * @param {string} content - El contenido actual del editor\n * @param {string} markdownType - El tipo de sintaxis a insertar ('bold', 'italic', etc.)\n * @param {string} placeholder - Texto de placeholder cuando no hay selección\n * @param {HTMLTextAreaElement} textAreaRef - Referencia al elemento textarea\n * @returns {string} - El contenido actualizado con la sintaxis de markdown insertada\n */\nexport const insertMarkdown = (content, markdownType, placeholder = '', textAreaRef) => {\n  if (!textAreaRef) return content;\n  const start = textAreaRef.selectionStart;\n  const end = textAreaRef.selectionEnd;\n\n  // Texto seleccionado o placeholder\n  const selectedText = start !== end ? content.substring(start, end) : placeholder;\n\n  // Formateamos el contenido seleccionado con la sintaxis de markdown\n  let formattedText;\n  switch (markdownType) {\n    case 'bold':\n      formattedText = `**${selectedText}**`;\n      break;\n    case 'italic':\n      formattedText = `*${selectedText}*`;\n      break;\n    case 'heading':\n      formattedText = `# ${selectedText}`;\n      break;\n    case 'subheading':\n      formattedText = `## ${selectedText}`;\n      break;\n    case 'link':\n      formattedText = `[${selectedText}](url)`;\n      break;\n    case 'image':\n      formattedText = `![${selectedText || 'Alt texto'}](url)`;\n      break;\n    case 'code':\n      formattedText = `\\`\\`\\`\\n${selectedText}\\n\\`\\`\\``;\n      break;\n    case 'list':\n      formattedText = `\\n- ${selectedText}`;\n      break;\n    case 'ordered-list':\n      formattedText = `\\n1. ${selectedText}`;\n      break;\n    case 'quote':\n      formattedText = `\\n> ${selectedText}`;\n      break;\n    case 'table':\n      formattedText = `\\n| Encabezado 1 | Encabezado 2 | Encabezado 3 |\\n| --- | --- | --- |\\n| Celda 1 | Celda 2 | Celda 3 |\\n| Celda 4 | Celda 5 | Celda 6 |`;\n      break;\n    case 'html':\n      formattedText = `<div>\\n  ${selectedText || 'Contenido HTML aquí'}\\n</div>`;\n      break;\n    case 'divider':\n      formattedText = `\\n\\n---\\n\\n`;\n      break;\n    default:\n      formattedText = selectedText;\n  }\n\n  // Actualizamos el contenido\n  const newContent = content.substring(0, start) + formattedText + content.substring(end);\n\n  // Enfocamos de nuevo el editor y movemos el cursor después del texto insertado\n  setTimeout(() => {\n    textAreaRef.focus();\n    textAreaRef.setSelectionRange(start + formattedText.length, start + formattedText.length);\n  }, 0);\n  return newContent;\n};\n\n/**\n * Inserta sintaxis HTML en el texto de acuerdo al tipo especificado\n * \n * @param {string} content - El contenido actual del editor\n * @param {string} htmlType - El tipo de sintaxis a insertar ('div', 'p', 'h1', etc.)\n * @param {string} placeholder - Texto de placeholder cuando no hay selección\n * @param {HTMLTextAreaElement} textAreaRef - Referencia al elemento textarea\n * @returns {string} - El contenido actualizado con la sintaxis HTML insertada\n */\nexport const insertHTML = (content, htmlType, placeholder = '', textAreaRef) => {\n  if (!textAreaRef) return content;\n  const start = textAreaRef.selectionStart;\n  const end = textAreaRef.selectionEnd;\n\n  // Texto seleccionado o placeholder\n  const selectedText = start !== end ? content.substring(start, end) : placeholder;\n\n  // Formateamos el contenido seleccionado con la sintaxis HTML apropiada\n  let formattedText;\n  switch (htmlType) {\n    case 'bold':\n      formattedText = `<strong>${selectedText || 'texto en negrita'}</strong>`;\n      break;\n    case 'italic':\n      formattedText = `<em>${selectedText || 'texto en cursiva'}</em>`;\n      break;\n    case 'heading':\n      // Verificar si ya está contenido en etiquetas h1\n      if (selectedText.match(/^<h1[^>]*>.*<\\/h1>$/)) {\n        formattedText = selectedText; // Mantener el formato actual\n      } else if (selectedText.match(/^<h[2-6][^>]*>.*<\\/h[2-6]>$/)) {\n        // Si es otro tipo de encabezado, extraer el texto y convertir a h1\n        const innerText = selectedText.replace(/^<h[2-6][^>]*>(.*)<\\/h[2-6]>$/, '$1');\n        formattedText = `<h1>${innerText || 'Título principal'}</h1>`;\n      } else {\n        formattedText = `<h1>${selectedText || 'Título principal'}</h1>`;\n      }\n      break;\n    case 'subheading':\n      // Verificar si ya está contenido en etiquetas h2\n      if (selectedText.match(/^<h2[^>]*>.*<\\/h2>$/)) {\n        formattedText = selectedText; // Mantener el formato actual\n      } else if (selectedText.match(/^<h1[^>]*>.*<\\/h1>$/)) {\n        // Si es h1, extraer el texto y convertir a h2\n        const innerText = selectedText.replace(/^<h1[^>]*>(.*)<\\/h1>$/, '$1');\n        formattedText = `<h2>${innerText || 'Subtítulo'}</h2>`;\n      } else if (selectedText.match(/^<h[3-6][^>]*>.*<\\/h[3-6]>$/)) {\n        // Si es h3-h6, extraer el texto y convertir a h2\n        const innerText = selectedText.replace(/^<h[3-6][^>]*>(.*)<\\/h[3-6]>$/, '$1');\n        formattedText = `<h2>${innerText || 'Subtítulo'}</h2>`;\n      } else {\n        formattedText = `<h2>${selectedText || 'Subtítulo'}</h2>`;\n      }\n      break;\n    case 'h3':\n      // Verificar si ya está contenido en etiquetas h3\n      if (selectedText.match(/^<h3[^>]*>.*<\\/h3>$/)) {\n        formattedText = selectedText; // Mantener el formato actual\n      } else if (selectedText.match(/^<h[1-2][^>]*>.*<\\/h[1-2]>$/)) {\n        // Si es h1 o h2, extraer el texto y convertir a h3\n        const innerText = selectedText.replace(/^<h[1-2][^>]*>(.*)<\\/h[1-2]>$/, '$1');\n        formattedText = `<h3>${innerText || 'Encabezado 3'}</h3>`;\n      } else if (selectedText.match(/^<h[4-6][^>]*>.*<\\/h[4-6]>$/)) {\n        // Si es h4-h6, extraer el texto y convertir a h3\n        const innerText = selectedText.replace(/^<h[4-6][^>]*>(.*)<\\/h[4-6]>$/, '$1');\n        formattedText = `<h3>${innerText || 'Encabezado 3'}</h3>`;\n      } else {\n        formattedText = `<h3>${selectedText || 'Encabezado 3'}</h3>`;\n      }\n      break;\n    case 'link':\n      formattedText = `<a href=\"#\">${selectedText || 'enlace'}</a>`;\n      break;\n    case 'image':\n      formattedText = `<img src=\"imagen.jpg\" alt=\"${selectedText || 'Descripción de la imagen'}\" />`;\n      break;\n    case 'list':\n      formattedText = `<ul>\\n  <li>${selectedText || 'Elemento 1'}</li>\\n  <li>Elemento 2</li>\\n</ul>`;\n      break;\n    case 'ordered-list':\n      formattedText = `<ol>\\n  <li>${selectedText || 'Elemento 1'}</li>\\n  <li>Elemento 2</li>\\n</ol>`;\n      break;\n    case 'quote':\n      formattedText = `<blockquote>\\n  ${selectedText || 'Cita'}\\n</blockquote>`;\n      break;\n    case 'code':\n      formattedText = `<pre><code>${selectedText || 'código aquí'}</code></pre>`;\n      break;\n    case 'table':\n      formattedText = `<table border=\"1\">\\n  <thead>\\n    <tr>\\n      <th>Encabezado 1</th>\\n      <th>Encabezado 2</th>\\n    </tr>\\n  </thead>\\n  <tbody>\\n    <tr>\\n      <td>Celda 1</td>\\n      <td>Celda 2</td>\\n    </tr>\\n  </tbody>\\n</table>`;\n      break;\n    case 'divider':\n      formattedText = `<hr />`;\n      break;\n    case 'paragraph':\n      formattedText = `<p>${selectedText || 'Párrafo'}</p>`;\n      break;\n    case 'div':\n      formattedText = `<div>\\n  ${selectedText || 'Contenido aquí'}\\n</div>`;\n      break;\n    case 'section':\n      formattedText = `<section>\\n  <h2>${selectedText || 'Título de sección'}</h2>\\n  <p>Contenido de la sección</p>\\n</section>`;\n      break;\n    case 'style':\n      formattedText = `<style>\\n  /* Estilos CSS */\\n  body {\\n    font-family: 'Poppins', sans-serif;\\n    color: #0b4444;\\n  }\\n</style>`;\n      break;\n    case 'script':\n      formattedText = `<script>\\n  // Código JavaScript\\n  document.addEventListener('DOMContentLoaded', () => {\\n    console.log('La página ha cargado');\\n  });\\n</script>`;\n      break;\n    case 'html-skeleton':\n      formattedText = `<!DOCTYPE html>\\n<html lang=\"es\">\\n<head>\\n  <meta charset=\"UTF-8\">\\n  <meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\">\\n  <title>${selectedText || 'Título del documento'}</title>\\n  <style>\\n    body {\\n      font-family: 'Poppins', sans-serif;\\n      line-height: 1.6;\\n      color: #0b4444;\\n      max-width: 800px;\\n      margin: 0 auto;\\n      padding: 20px;\\n    }\\n  </style>\\n</head>\\n<body>\\n  <h1>${selectedText || 'Título principal'}</h1>\\n  <p>Contenido del documento</p>\\n</body>\\n</html>`;\n      break;\n    case 'timeline':\n      formattedText = `<div class=\"timeline\">\\n  <div class=\"timeline-item\">\\n    <div class=\"timeline-date\">Día 1</div>\\n    <div class=\"timeline-content\">\\n      <h3>Estudiar nuevo material (2 horas)</h3>\\n      <p>Lectura inicial y comprensión de conceptos</p>\\n    </div>\\n  </div>\\n  <div class=\"timeline-item\">\\n    <div class=\"timeline-date\">Día 3</div>\\n    <div class=\"timeline-content\">\\n      <h3>Repasar material (1 hora)</h3>\\n      <p>Primera sesión de repaso espaciado</p>\\n    </div>\\n  </div>\\n</div>`;\n      break;\n    case 'custom-section':\n      formattedText = `<section class=\"metodologia\">\\n  <h2>${selectedText || 'Metodología de Estudio'}</h2>\\n  <div class=\"metodo-grid\">\\n    <div class=\"metodo-card\">\\n      <h3>Fase 1: Adquisición</h3>\\n      <p>Lectura activa, subrayado y toma de notas</p>\\n    </div>\\n    <div class=\"metodo-card\">\\n      <h3>Fase 2: Comprensión</h3>\\n      <p>Mapas mentales y resolución de ejemplos</p>\\n    </div>\\n  </div>\\n</section>`;\n      break;\n    default:\n      formattedText = selectedText;\n  }\n\n  // Actualizamos el contenido\n  const newContent = content.substring(0, start) + formattedText + content.substring(end);\n\n  // Enfocamos de nuevo el editor y movemos el cursor después del texto insertado\n  setTimeout(() => {\n    textAreaRef.focus();\n    textAreaRef.setSelectionRange(start + formattedText.length, start + formattedText.length);\n  }, 0);\n  return newContent;\n};\n\n/**\n * Inserta sintaxis simple en el texto de acuerdo al tipo especificado\n * \n * @param {string} content - El contenido actual del editor\n * @param {string} simpleType - El tipo de sintaxis a insertar ('bold', 'italic', etc.)\n * @param {string} placeholder - Texto de placeholder cuando no hay selección\n * @param {HTMLTextAreaElement} textAreaRef - Referencia al elemento textarea\n * @returns {string} - El contenido actualizado con la sintaxis simple insertada\n */\nexport const insertSimple = (content, simpleType, placeholder = '', textAreaRef) => {\n  if (!textAreaRef) return content;\n  const start = textAreaRef.selectionStart;\n  const end = textAreaRef.selectionEnd;\n\n  // Texto seleccionado o placeholder\n  const selectedText = start !== end ? content.substring(start, end) : placeholder;\n\n  // Formateamos el contenido seleccionado con la sintaxis simple\n  let formattedText;\n  switch (simpleType) {\n    case 'bold':\n      formattedText = `<b>${selectedText}</b>`;\n      break;\n    case 'italic':\n      formattedText = `<i>${selectedText}</i>`;\n      break;\n    case 'heading':\n      formattedText = `<h1>${selectedText}</h1>`;\n      break;\n    case 'subheading':\n      formattedText = `<h2>${selectedText}</h2>`;\n      break;\n    case 'link':\n      formattedText = `<a href=\"#\">${selectedText}</a>`;\n      break;\n    case 'image':\n      formattedText = `<img src=\"imagen.jpg\" alt=\"${selectedText}\" />`;\n      break;\n    case 'list':\n      formattedText = `<ul><li>${selectedText}</li></ul>`;\n      break;\n    case 'ordered-list':\n      formattedText = `<ol><li>${selectedText}</li></ol>`;\n      break;\n    case 'quote':\n      formattedText = `<blockquote>${selectedText}</blockquote>`;\n      break;\n    case 'divider':\n      formattedText = `<hr />`;\n      break;\n    case 'font-size':\n      formattedText = `<span style=\"font-size:${placeholder};\">${selectedText}</span>`;\n      break;\n    case 'font-family':\n      formattedText = `<span style=\"font-family:${placeholder};\">${selectedText}</span>`;\n      break;\n    default:\n      formattedText = selectedText;\n  }\n\n  // Actualizamos el contenido\n  const newContent = content.substring(0, start) + formattedText + content.substring(end);\n\n  // Enfocamos de nuevo el editor y movemos el cursor después del texto insertado\n  setTimeout(() => {\n    textAreaRef.focus();\n    textAreaRef.setSelectionRange(start + formattedText.length, start + formattedText.length);\n  }, 0);\n  return newContent;\n};","map":{"version":3,"names":["insertMarkdown","content","markdownType","placeholder","textAreaRef","start","selectionStart","end","selectionEnd","selectedText","substring","formattedText","newContent","setTimeout","focus","setSelectionRange","length","insertHTML","htmlType","match","innerText","replace","insertSimple","simpleType"],"sources":["C:/Users/damva/EducStation/src/components/admin/utils/editorUtils.js"],"sourcesContent":["// src/components/admin/utils/editorUtils.js\n\n/**\n * Inserta sintaxis de markdown en el texto de acuerdo al tipo especificado\n * \n * @param {string} content - El contenido actual del editor\n * @param {string} markdownType - El tipo de sintaxis a insertar ('bold', 'italic', etc.)\n * @param {string} placeholder - Texto de placeholder cuando no hay selección\n * @param {HTMLTextAreaElement} textAreaRef - Referencia al elemento textarea\n * @returns {string} - El contenido actualizado con la sintaxis de markdown insertada\n */\nexport const insertMarkdown = (content, markdownType, placeholder = '', textAreaRef) => {\n    if (!textAreaRef) return content;\n    \n    const start = textAreaRef.selectionStart;\n    const end = textAreaRef.selectionEnd;\n    \n    // Texto seleccionado o placeholder\n    const selectedText = start !== end \n      ? content.substring(start, end) \n      : placeholder;\n    \n    // Formateamos el contenido seleccionado con la sintaxis de markdown\n    let formattedText;\n    switch(markdownType) {\n      case 'bold':\n        formattedText = `**${selectedText}**`;\n        break;\n      case 'italic':\n        formattedText = `*${selectedText}*`;\n        break;\n      case 'heading':\n        formattedText = `# ${selectedText}`;\n        break;\n      case 'subheading':\n        formattedText = `## ${selectedText}`;\n        break;\n      case 'link':\n        formattedText = `[${selectedText}](url)`;\n        break;\n      case 'image':\n        formattedText = `![${selectedText || 'Alt texto'}](url)`;\n        break;\n      case 'code':\n        formattedText = `\\`\\`\\`\\n${selectedText}\\n\\`\\`\\``;\n        break;\n      case 'list':\n        formattedText = `\\n- ${selectedText}`;\n        break;\n      case 'ordered-list':\n        formattedText = `\\n1. ${selectedText}`;\n        break;\n      case 'quote':\n        formattedText = `\\n> ${selectedText}`;\n        break;\n      case 'table':\n        formattedText = `\\n| Encabezado 1 | Encabezado 2 | Encabezado 3 |\\n| --- | --- | --- |\\n| Celda 1 | Celda 2 | Celda 3 |\\n| Celda 4 | Celda 5 | Celda 6 |`;\n        break;\n      case 'html':\n        formattedText = `<div>\\n  ${selectedText || 'Contenido HTML aquí'}\\n</div>`;\n        break;\n      case 'divider':\n        formattedText = `\\n\\n---\\n\\n`;\n        break;\n      default:\n        formattedText = selectedText;\n    }\n    \n    // Actualizamos el contenido\n    const newContent = \n      content.substring(0, start) + \n      formattedText + \n      content.substring(end);\n    \n    // Enfocamos de nuevo el editor y movemos el cursor después del texto insertado\n    setTimeout(() => {\n      textAreaRef.focus();\n      textAreaRef.setSelectionRange(\n        start + formattedText.length,\n        start + formattedText.length\n      );\n    }, 0);\n    \n    return newContent;\n  };\n  \n  /**\n   * Inserta sintaxis HTML en el texto de acuerdo al tipo especificado\n   * \n   * @param {string} content - El contenido actual del editor\n   * @param {string} htmlType - El tipo de sintaxis a insertar ('div', 'p', 'h1', etc.)\n   * @param {string} placeholder - Texto de placeholder cuando no hay selección\n   * @param {HTMLTextAreaElement} textAreaRef - Referencia al elemento textarea\n   * @returns {string} - El contenido actualizado con la sintaxis HTML insertada\n   */\n  export const insertHTML = (content, htmlType, placeholder = '', textAreaRef) => {\n    if (!textAreaRef) return content;\n    \n    const start = textAreaRef.selectionStart;\n    const end = textAreaRef.selectionEnd;\n    \n    // Texto seleccionado o placeholder\n    const selectedText = start !== end \n      ? content.substring(start, end) \n      : placeholder;\n    \n    // Formateamos el contenido seleccionado con la sintaxis HTML apropiada\n    let formattedText;\n    switch(htmlType) {\n      case 'bold':\n        formattedText = `<strong>${selectedText || 'texto en negrita'}</strong>`;\n        break;\n      case 'italic':\n        formattedText = `<em>${selectedText || 'texto en cursiva'}</em>`;\n        break;\n        case 'heading':\n          // Verificar si ya está contenido en etiquetas h1\n          if (selectedText.match(/^<h1[^>]*>.*<\\/h1>$/)) {\n            formattedText = selectedText; // Mantener el formato actual\n          } else if (selectedText.match(/^<h[2-6][^>]*>.*<\\/h[2-6]>$/)) {\n            // Si es otro tipo de encabezado, extraer el texto y convertir a h1\n            const innerText = selectedText.replace(/^<h[2-6][^>]*>(.*)<\\/h[2-6]>$/, '$1');\n            formattedText = `<h1>${innerText || 'Título principal'}</h1>`;\n          } else {\n            formattedText = `<h1>${selectedText || 'Título principal'}</h1>`;\n          }\n          break;\n        case 'subheading':\n          // Verificar si ya está contenido en etiquetas h2\n          if (selectedText.match(/^<h2[^>]*>.*<\\/h2>$/)) {\n            formattedText = selectedText; // Mantener el formato actual\n          } else if (selectedText.match(/^<h1[^>]*>.*<\\/h1>$/)) {\n            // Si es h1, extraer el texto y convertir a h2\n            const innerText = selectedText.replace(/^<h1[^>]*>(.*)<\\/h1>$/, '$1');\n            formattedText = `<h2>${innerText || 'Subtítulo'}</h2>`;\n          } else if (selectedText.match(/^<h[3-6][^>]*>.*<\\/h[3-6]>$/)) {\n            // Si es h3-h6, extraer el texto y convertir a h2\n            const innerText = selectedText.replace(/^<h[3-6][^>]*>(.*)<\\/h[3-6]>$/, '$1');\n            formattedText = `<h2>${innerText || 'Subtítulo'}</h2>`;\n          } else {\n            formattedText = `<h2>${selectedText || 'Subtítulo'}</h2>`;\n          }\n          break;\n        case 'h3':\n          // Verificar si ya está contenido en etiquetas h3\n          if (selectedText.match(/^<h3[^>]*>.*<\\/h3>$/)) {\n            formattedText = selectedText; // Mantener el formato actual\n          } else if (selectedText.match(/^<h[1-2][^>]*>.*<\\/h[1-2]>$/)) {\n            // Si es h1 o h2, extraer el texto y convertir a h3\n            const innerText = selectedText.replace(/^<h[1-2][^>]*>(.*)<\\/h[1-2]>$/, '$1');\n            formattedText = `<h3>${innerText || 'Encabezado 3'}</h3>`;\n          } else if (selectedText.match(/^<h[4-6][^>]*>.*<\\/h[4-6]>$/)) {\n            // Si es h4-h6, extraer el texto y convertir a h3\n            const innerText = selectedText.replace(/^<h[4-6][^>]*>(.*)<\\/h[4-6]>$/, '$1');\n            formattedText = `<h3>${innerText || 'Encabezado 3'}</h3>`;\n          } else {\n            formattedText = `<h3>${selectedText || 'Encabezado 3'}</h3>`;\n          }\n          break;\n      case 'link':\n        formattedText = `<a href=\"#\">${selectedText || 'enlace'}</a>`;\n        break;\n      case 'image':\n        formattedText = `<img src=\"imagen.jpg\" alt=\"${selectedText || 'Descripción de la imagen'}\" />`;\n        break;\n      case 'list':\n        formattedText = `<ul>\\n  <li>${selectedText || 'Elemento 1'}</li>\\n  <li>Elemento 2</li>\\n</ul>`;\n        break;\n      case 'ordered-list':\n        formattedText = `<ol>\\n  <li>${selectedText || 'Elemento 1'}</li>\\n  <li>Elemento 2</li>\\n</ol>`;\n        break;\n      case 'quote':\n        formattedText = `<blockquote>\\n  ${selectedText || 'Cita'}\\n</blockquote>`;\n        break;\n      case 'code':\n        formattedText = `<pre><code>${selectedText || 'código aquí'}</code></pre>`;\n        break;\n      case 'table':\n        formattedText = `<table border=\"1\">\\n  <thead>\\n    <tr>\\n      <th>Encabezado 1</th>\\n      <th>Encabezado 2</th>\\n    </tr>\\n  </thead>\\n  <tbody>\\n    <tr>\\n      <td>Celda 1</td>\\n      <td>Celda 2</td>\\n    </tr>\\n  </tbody>\\n</table>`;\n        break;\n      case 'divider':\n        formattedText = `<hr />`;\n        break;\n      case 'paragraph':\n        formattedText = `<p>${selectedText || 'Párrafo'}</p>`;\n        break;\n      case 'div':\n        formattedText = `<div>\\n  ${selectedText || 'Contenido aquí'}\\n</div>`;\n        break;\n      case 'section':\n        formattedText = `<section>\\n  <h2>${selectedText || 'Título de sección'}</h2>\\n  <p>Contenido de la sección</p>\\n</section>`;\n        break;\n      case 'style':\n        formattedText = `<style>\\n  /* Estilos CSS */\\n  body {\\n    font-family: 'Poppins', sans-serif;\\n    color: #0b4444;\\n  }\\n</style>`;\n        break;\n      case 'script':\n        formattedText = `<script>\\n  // Código JavaScript\\n  document.addEventListener('DOMContentLoaded', () => {\\n    console.log('La página ha cargado');\\n  });\\n</script>`;\n        break;\n      case 'html-skeleton':\n        formattedText = `<!DOCTYPE html>\\n<html lang=\"es\">\\n<head>\\n  <meta charset=\"UTF-8\">\\n  <meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\">\\n  <title>${selectedText || 'Título del documento'}</title>\\n  <style>\\n    body {\\n      font-family: 'Poppins', sans-serif;\\n      line-height: 1.6;\\n      color: #0b4444;\\n      max-width: 800px;\\n      margin: 0 auto;\\n      padding: 20px;\\n    }\\n  </style>\\n</head>\\n<body>\\n  <h1>${selectedText || 'Título principal'}</h1>\\n  <p>Contenido del documento</p>\\n</body>\\n</html>`;\n        break;\n      case 'timeline':\n        formattedText = `<div class=\"timeline\">\\n  <div class=\"timeline-item\">\\n    <div class=\"timeline-date\">Día 1</div>\\n    <div class=\"timeline-content\">\\n      <h3>Estudiar nuevo material (2 horas)</h3>\\n      <p>Lectura inicial y comprensión de conceptos</p>\\n    </div>\\n  </div>\\n  <div class=\"timeline-item\">\\n    <div class=\"timeline-date\">Día 3</div>\\n    <div class=\"timeline-content\">\\n      <h3>Repasar material (1 hora)</h3>\\n      <p>Primera sesión de repaso espaciado</p>\\n    </div>\\n  </div>\\n</div>`;\n        break;\n      case 'custom-section':\n        formattedText = `<section class=\"metodologia\">\\n  <h2>${selectedText || 'Metodología de Estudio'}</h2>\\n  <div class=\"metodo-grid\">\\n    <div class=\"metodo-card\">\\n      <h3>Fase 1: Adquisición</h3>\\n      <p>Lectura activa, subrayado y toma de notas</p>\\n    </div>\\n    <div class=\"metodo-card\">\\n      <h3>Fase 2: Comprensión</h3>\\n      <p>Mapas mentales y resolución de ejemplos</p>\\n    </div>\\n  </div>\\n</section>`;\n        break;\n      default:\n        formattedText = selectedText;\n    }\n    \n    // Actualizamos el contenido\n    const newContent = \n      content.substring(0, start) + \n      formattedText + \n      content.substring(end);\n    \n    // Enfocamos de nuevo el editor y movemos el cursor después del texto insertado\n    setTimeout(() => {\n      textAreaRef.focus();\n      textAreaRef.setSelectionRange(\n        start + formattedText.length,\n        start + formattedText.length\n      );\n    }, 0);\n    \n    return newContent;\n  };\n\n/**\n * Inserta sintaxis simple en el texto de acuerdo al tipo especificado\n * \n * @param {string} content - El contenido actual del editor\n * @param {string} simpleType - El tipo de sintaxis a insertar ('bold', 'italic', etc.)\n * @param {string} placeholder - Texto de placeholder cuando no hay selección\n * @param {HTMLTextAreaElement} textAreaRef - Referencia al elemento textarea\n * @returns {string} - El contenido actualizado con la sintaxis simple insertada\n */\nexport const insertSimple = (content, simpleType, placeholder = '', textAreaRef) => {\n  if (!textAreaRef) return content;\n  \n  const start = textAreaRef.selectionStart;\n  const end = textAreaRef.selectionEnd;\n  \n  // Texto seleccionado o placeholder\n  const selectedText = start !== end \n    ? content.substring(start, end) \n    : placeholder;\n  \n  // Formateamos el contenido seleccionado con la sintaxis simple\n  let formattedText;\n  switch(simpleType) {\n    case 'bold':\n      formattedText = `<b>${selectedText}</b>`;\n      break;\n    case 'italic':\n      formattedText = `<i>${selectedText}</i>`;\n      break;\n    case 'heading':\n      formattedText = `<h1>${selectedText}</h1>`;\n      break;\n    case 'subheading':\n      formattedText = `<h2>${selectedText}</h2>`;\n      break;\n    case 'link':\n      formattedText = `<a href=\"#\">${selectedText}</a>`;\n      break;\n    case 'image':\n      formattedText = `<img src=\"imagen.jpg\" alt=\"${selectedText}\" />`;\n      break;\n    case 'list':\n      formattedText = `<ul><li>${selectedText}</li></ul>`;\n      break;\n    case 'ordered-list':\n      formattedText = `<ol><li>${selectedText}</li></ol>`;\n      break;\n    case 'quote':\n      formattedText = `<blockquote>${selectedText}</blockquote>`;\n      break;\n    case 'divider':\n      formattedText = `<hr />`;\n      break;\n    case 'font-size':\n      formattedText = `<span style=\"font-size:${placeholder};\">${selectedText}</span>`;\n      break;\n    case 'font-family':\n      formattedText = `<span style=\"font-family:${placeholder};\">${selectedText}</span>`;\n      break;\n    default:\n      formattedText = selectedText;\n  }\n  \n  // Actualizamos el contenido\n  const newContent = \n    content.substring(0, start) + \n    formattedText + \n    content.substring(end);\n  \n  // Enfocamos de nuevo el editor y movemos el cursor después del texto insertado\n  setTimeout(() => {\n    textAreaRef.focus();\n    textAreaRef.setSelectionRange(\n      start + formattedText.length,\n      start + formattedText.length\n    );\n  }, 0);\n  \n  return newContent;\n};"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}