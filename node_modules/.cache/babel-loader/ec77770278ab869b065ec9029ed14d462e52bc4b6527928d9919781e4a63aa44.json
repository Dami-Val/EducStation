{"ast":null,"code":"var _jsxFileName = \"C:\\\\Users\\\\damva\\\\EducStation\\\\src\\\\components\\\\admin\\\\FloatingToolbar.jsx\",\n  _s = $RefreshSig$();\n// Modificaciones a realizar en src/components/admin/FloatingToolbar.jsx\n\nimport React, { useState, useEffect, useRef } from 'react';\nimport Tooltip from '../ui/Tooltip';\n\n// Tamaños de fuente predeterminados como en Word\nimport { jsxDEV as _jsxDEV } from \"react/jsx-dev-runtime\";\nconst FONT_SIZES = [8, 9, 10, 11, 12, 14, 16, 18, 20, 22, 24, 26, 28, 36, 48, 72, 120];\nconst FloatingToolbar = ({\n  onFormatText,\n  activeFormats,\n  editorRef,\n  fontSize,\n  setFontSize\n}) => {\n  _s();\n  // Estados originales\n  const [visible, setVisible] = useState(false);\n  const [position, setPosition] = useState({\n    top: 0,\n    left: 0\n  });\n  const [showFontSizeMenu, setShowFontSizeMenu] = useState(false);\n  const [customFontSize, setCustomFontSize] = useState('');\n  const [isEditingFontSize, setIsEditingFontSize] = useState(false);\n  const [savedSelection, setSavedSelection] = useState(null);\n  const [activeTooltip, setActiveTooltip] = useState(null);\n\n  // Nuevo estado para control de escritura\n  const [isTyping, setIsTyping] = useState(false);\n  const typingTimerRef = useRef(null);\n  const TYPING_TIMEOUT = 800; // Tiempo en ms para considerar que se dejó de escribir (ajustable)\n\n  // Referencias\n  const toolbarRef = useRef(null);\n  const fontSizeMenuRef = useRef(null);\n  const customFontInputRef = useRef(null);\n\n  // Función para detectar inicio de escritura\n  const handleTypingStart = () => {\n    // Ocultar la barra mientras se escribe\n    setVisible(false);\n\n    // Limpiar el timer anterior si existe\n    if (typingTimerRef.current) {\n      clearTimeout(typingTimerRef.current);\n    }\n\n    // Establecer que se está escribiendo\n    setIsTyping(true);\n\n    // Configurar un nuevo timer para detectar cuando se deja de escribir\n    typingTimerRef.current = setTimeout(() => {\n      setIsTyping(false);\n      checkSelection(); // Comprobar posición del cursor y mostrar la barra\n    }, TYPING_TIMEOUT);\n  };\n\n  // Mostrar tooltip\n  const showTooltip = id => {\n    setActiveTooltip(id);\n  };\n\n  // Ocultar tooltip\n  const hideTooltip = () => {\n    setActiveTooltip(null);\n  };\n\n  // ... [Resto de estilos y funciones originales] ...\n\n  // Función modificada para guardar la selección actual\n  const saveSelection = () => {\n    const selection = window.getSelection();\n    if (selection.rangeCount > 0) {\n      const ranges = [];\n      for (let i = 0; i < selection.rangeCount; i++) {\n        ranges.push(selection.getRangeAt(i).cloneRange());\n      }\n      setSavedSelection(ranges);\n      return ranges;\n    }\n    return null;\n  };\n\n  // Función para restaurar la selección guardada\n  const restoreSelection = (ranges = savedSelection) => {\n    if (!ranges) return false;\n    const selection = window.getSelection();\n    selection.removeAllRanges();\n    ranges.forEach(range => {\n      selection.addRange(range);\n    });\n    return true;\n  };\n\n  // Función modificada para verificar la selección de texto\n  const checkSelection = event => {\n    try {\n      // Si se está escribiendo, no mostramos la barra\n      if (isTyping) {\n        setVisible(false);\n        return;\n      }\n      const selection = window.getSelection();\n\n      // Evitar ocultar la barra si estamos interactuando con elementos de la barra\n      if (toolbarRef.current && (toolbarRef.current.contains(document.activeElement) || event && toolbarRef.current.contains(event.target))) {\n        return;\n      }\n\n      // Evitar ocultar la barra si interactuamos con el menú de tamaño de fuente\n      if (fontSizeMenuRef.current && (fontSizeMenuRef.current.contains(document.activeElement) || selection.anchorNode && fontSizeMenuRef.current.contains(selection.anchorNode))) {\n        return;\n      }\n\n      // Verificar si el editor está activo\n      const isEditorActive = editorRef.current === document.activeElement;\n\n      // Verificar si tenemos una selección válida\n      const hasSelection = selection && !selection.isCollapsed && editorRef.current;\n\n      // Si ni el editor está activo ni hay selección, ocultar la barra\n      if (!isEditorActive && !hasSelection) {\n        setVisible(false);\n        setShowFontSizeMenu(false);\n        return;\n      }\n\n      // Verificar si la selección o el cursor está dentro del editor\n      let isInEditor = false;\n      if (isEditorActive) {\n        isInEditor = true;\n      } else if (hasSelection) {\n        const range = selection.getRangeAt(0);\n        let container = range.commonAncestorContainer;\n\n        // Si el contenedor es un nodo de texto, obtener su elemento padre\n        if (container.nodeType === 3) {\n          container = container.parentNode;\n        }\n\n        // Verificar si el contenedor o algún antecesor es el editor\n        let current = container;\n        while (current && !isInEditor) {\n          if (current === editorRef.current) {\n            isInEditor = true;\n          }\n          current = current.parentNode;\n        }\n      }\n      if (!isInEditor) {\n        setVisible(false);\n        setShowFontSizeMenu(false);\n        return;\n      }\n\n      // Calcular la posición de la barra\n      const editorRect = editorRef.current.getBoundingClientRect();\n\n      // Calculamos la altura de la barra\n      const toolbarHeight = toolbarRef.current ? toolbarRef.current.offsetHeight : 40;\n      const toolbarWidth = toolbarRef.current ? toolbarRef.current.offsetWidth : 200;\n      let newPosition;\n      if (hasSelection) {\n        // Si hay selección, posicionar debajo de la selección\n        const rect = selection.getRangeAt(0).getBoundingClientRect();\n        if (rect.width === 0) {\n          setVisible(false);\n          setShowFontSizeMenu(false);\n          return;\n        }\n        newPosition = {\n          // Posicionamos la barra DEBAJO de la línea de texto seleccionada\n          top: rect.bottom - editorRect.top + 8,\n          // Centramos horizontalmente respecto a la selección\n          left: rect.left - editorRect.left + rect.width / 2\n        };\n      } else {\n        // Si solo está activo el editor sin selección, posicionar debajo del cursor\n        try {\n          // Obtenemos la posición del cursor (caret)\n          const range = selection.getRangeAt(0);\n\n          // Creamos un elemento temporal para medir la posición exacta del cursor\n          const span = document.createElement('span');\n          span.style.display = 'inline-block';\n          span.style.height = '0px';\n          span.style.width = '0px';\n          span.style.overflow = 'hidden';\n          span.innerHTML = '.'; // Necesitamos algún contenido para que tenga dimensiones\n\n          // Guardamos una copia del rango para restaurarlo después\n          const rangeCopy = range.cloneRange();\n\n          // Insertamos temporalmente el span en la posición del cursor\n          range.insertNode(span);\n\n          // Obtenemos la posición del span (posición del cursor)\n          const spanRect = span.getBoundingClientRect();\n\n          // Eliminamos el span temporal para no afectar al contenido\n          if (span.parentNode) {\n            span.parentNode.removeChild(span);\n          }\n\n          // Restauramos la selección original\n          selection.removeAllRanges();\n          selection.addRange(rangeCopy);\n\n          // Calculamos la posición de la barra basada en la posición del cursor\n          newPosition = {\n            // Posicionamos la barra justo debajo del cursor\n            top: spanRect.bottom - editorRect.top + 8,\n            // Un pequeño margen debajo\n            // Alineamos horizontalmente con el cursor\n            left: spanRect.left - editorRect.left\n          };\n\n          // Ajustes para que la barra no se salga de los límites del editor\n          if (newPosition.left < toolbarWidth / 2 + 10) {\n            newPosition.left = toolbarWidth / 2 + 10;\n          } else if (newPosition.left > editorRect.width - toolbarWidth / 2 - 10) {\n            newPosition.left = editorRect.width - toolbarWidth / 2 - 10;\n          }\n        } catch (error) {\n          // Si hay algún error, usamos una posición predeterminada segura\n          console.error('Error al obtener posición del cursor:', error);\n          newPosition = {\n            top: 50,\n            // Posición vertical segura\n            left: editorRect.width / 2 // Centrado horizontalmente\n          };\n        }\n      }\n\n      // Ajustar para que no se salga del editor\n      if (toolbarRef.current) {\n        // Ajuste horizontal para que no se salga por los lados\n        if (newPosition.left + toolbarWidth / 2 > editorRect.width) {\n          newPosition.left = editorRect.width - toolbarWidth / 2 - 10;\n        }\n        if (newPosition.left - toolbarWidth / 2 < 0) {\n          newPosition.left = toolbarWidth / 2 + 10;\n        }\n\n        // Si no hay espacio arriba, colocar debajo de la selección (para el caso de selección)\n        if (hasSelection && newPosition.top < 0) {\n          const rect = selection.getRangeAt(0).getBoundingClientRect();\n          newPosition.top = rect.bottom - editorRect.top + 8;\n        }\n      }\n      setPosition(newPosition);\n      setVisible(true);\n\n      // Guardar la selección actual para poder restaurarla más tarde\n      saveSelection();\n    } catch (error) {\n      console.error('Error al verificar selección:', error);\n      setVisible(false);\n      setShowFontSizeMenu(false);\n    }\n  };\n\n  // ... [resto de funciones originales] ...\n\n  // Modificar useEffect para eventos del editor\n  useEffect(() => {\n    // No agregar event listeners si no hay editorRef\n    if (!editorRef || !editorRef.current) return;\n    document.addEventListener('selectionchange', checkSelection);\n    editorRef.current.addEventListener('mouseup', checkSelection);\n    editorRef.current.addEventListener('focus', checkSelection);\n\n    // Añadir evento para detectar inicio de escritura\n    const handleKeyDown = event => {\n      // Solo reaccionamos a teclas \"normales\", no a atajos o teclas especiales\n      const isModifierKey = event.ctrlKey || event.metaKey || event.altKey;\n      const isNavigationKey = ['ArrowUp', 'ArrowDown', 'ArrowLeft', 'ArrowRight', 'Home', 'End', 'PageUp', 'PageDown'].includes(event.key);\n      if (!isModifierKey && !isNavigationKey) {\n        handleTypingStart();\n      }\n    };\n\n    // Ya no mostramos la barra en keyup\n    editorRef.current.addEventListener('keydown', handleKeyDown);\n\n    // Limpiar event listeners\n    return () => {\n      document.removeEventListener('selectionchange', checkSelection);\n      if (editorRef.current) {\n        editorRef.current.removeEventListener('mouseup', checkSelection);\n        editorRef.current.removeEventListener('focus', checkSelection);\n        editorRef.current.removeEventListener('keydown', handleKeyDown);\n      }\n\n      // Limpiar el timer si existe\n      if (typingTimerRef.current) {\n        clearTimeout(typingTimerRef.current);\n      }\n    };\n  }, [editorRef === null || editorRef === void 0 ? void 0 : editorRef.current, isTyping]);\n\n  // ... [resto del código original] ...\n\n  return /*#__PURE__*/_jsxDEV(\"div\", {\n    ref: toolbarRef,\n    style: {\n      ...styles.floatingBar,\n      top: `${position.top}px`,\n      left: `${position.left}px`,\n      transform: 'translateX(-50%)' // Centrar horizontalmente respecto al punto de referencia\n    }\n  }, void 0, false, {\n    fileName: _jsxFileName,\n    lineNumber: 317,\n    columnNumber: 5\n  }, this);\n};\n_s(FloatingToolbar, \"4PCgA9JYihMmWDDRodxKm4+O064=\");\n_c = FloatingToolbar;\nexport default FloatingToolbar;\nvar _c;\n$RefreshReg$(_c, \"FloatingToolbar\");","map":{"version":3,"names":["React","useState","useEffect","useRef","Tooltip","jsxDEV","_jsxDEV","FONT_SIZES","FloatingToolbar","onFormatText","activeFormats","editorRef","fontSize","setFontSize","_s","visible","setVisible","position","setPosition","top","left","showFontSizeMenu","setShowFontSizeMenu","customFontSize","setCustomFontSize","isEditingFontSize","setIsEditingFontSize","savedSelection","setSavedSelection","activeTooltip","setActiveTooltip","isTyping","setIsTyping","typingTimerRef","TYPING_TIMEOUT","toolbarRef","fontSizeMenuRef","customFontInputRef","handleTypingStart","current","clearTimeout","setTimeout","checkSelection","showTooltip","id","hideTooltip","saveSelection","selection","window","getSelection","rangeCount","ranges","i","push","getRangeAt","cloneRange","restoreSelection","removeAllRanges","forEach","range","addRange","event","contains","document","activeElement","target","anchorNode","isEditorActive","hasSelection","isCollapsed","isInEditor","container","commonAncestorContainer","nodeType","parentNode","editorRect","getBoundingClientRect","toolbarHeight","offsetHeight","toolbarWidth","offsetWidth","newPosition","rect","width","bottom","span","createElement","style","display","height","overflow","innerHTML","rangeCopy","insertNode","spanRect","removeChild","error","console","addEventListener","handleKeyDown","isModifierKey","ctrlKey","metaKey","altKey","isNavigationKey","includes","key","removeEventListener","ref","styles","floatingBar","transform","fileName","_jsxFileName","lineNumber","columnNumber","_c","$RefreshReg$"],"sources":["C:/Users/damva/EducStation/src/components/admin/FloatingToolbar.jsx"],"sourcesContent":["// Modificaciones a realizar en src/components/admin/FloatingToolbar.jsx\r\n\r\nimport React, { useState, useEffect, useRef } from 'react';\r\nimport Tooltip from '../ui/Tooltip';\r\n\r\n// Tamaños de fuente predeterminados como en Word\r\nconst FONT_SIZES = [8, 9, 10, 11, 12, 14, 16, 18, 20, 22, 24, 26, 28, 36, 48, 72, 120];\r\n\r\nconst FloatingToolbar = ({ onFormatText, activeFormats, editorRef, fontSize, setFontSize }) => {\r\n  // Estados originales\r\n  const [visible, setVisible] = useState(false);\r\n  const [position, setPosition] = useState({ top: 0, left: 0 });\r\n  const [showFontSizeMenu, setShowFontSizeMenu] = useState(false);\r\n  const [customFontSize, setCustomFontSize] = useState('');\r\n  const [isEditingFontSize, setIsEditingFontSize] = useState(false);\r\n  const [savedSelection, setSavedSelection] = useState(null);\r\n  const [activeTooltip, setActiveTooltip] = useState(null);\r\n  \r\n  // Nuevo estado para control de escritura\r\n  const [isTyping, setIsTyping] = useState(false);\r\n  const typingTimerRef = useRef(null);\r\n  const TYPING_TIMEOUT = 800; // Tiempo en ms para considerar que se dejó de escribir (ajustable)\r\n  \r\n  // Referencias\r\n  const toolbarRef = useRef(null);\r\n  const fontSizeMenuRef = useRef(null);\r\n  const customFontInputRef = useRef(null);\r\n  \r\n  // Función para detectar inicio de escritura\r\n  const handleTypingStart = () => {\r\n    // Ocultar la barra mientras se escribe\r\n    setVisible(false);\r\n    \r\n    // Limpiar el timer anterior si existe\r\n    if (typingTimerRef.current) {\r\n      clearTimeout(typingTimerRef.current);\r\n    }\r\n    \r\n    // Establecer que se está escribiendo\r\n    setIsTyping(true);\r\n    \r\n    // Configurar un nuevo timer para detectar cuando se deja de escribir\r\n    typingTimerRef.current = setTimeout(() => {\r\n      setIsTyping(false);\r\n      checkSelection(); // Comprobar posición del cursor y mostrar la barra\r\n    }, TYPING_TIMEOUT);\r\n  };\r\n  \r\n  // Mostrar tooltip\r\n  const showTooltip = (id) => {\r\n    setActiveTooltip(id);\r\n  };\r\n\r\n  // Ocultar tooltip\r\n  const hideTooltip = () => {\r\n    setActiveTooltip(null);\r\n  };\r\n  \r\n  // ... [Resto de estilos y funciones originales] ...\r\n  \r\n  // Función modificada para guardar la selección actual\r\n  const saveSelection = () => {\r\n    const selection = window.getSelection();\r\n    if (selection.rangeCount > 0) {\r\n      const ranges = [];\r\n      for (let i = 0; i < selection.rangeCount; i++) {\r\n        ranges.push(selection.getRangeAt(i).cloneRange());\r\n      }\r\n      setSavedSelection(ranges);\r\n      return ranges;\r\n    }\r\n    return null;\r\n  };\r\n\r\n  // Función para restaurar la selección guardada\r\n  const restoreSelection = (ranges = savedSelection) => {\r\n    if (!ranges) return false;\r\n    \r\n    const selection = window.getSelection();\r\n    selection.removeAllRanges();\r\n    \r\n    ranges.forEach(range => {\r\n      selection.addRange(range);\r\n    });\r\n    \r\n    return true;\r\n  };\r\n\r\n  // Función modificada para verificar la selección de texto\r\n  const checkSelection = (event) => {\r\n    try {\r\n      // Si se está escribiendo, no mostramos la barra\r\n      if (isTyping) {\r\n        setVisible(false);\r\n        return;\r\n      }\r\n      \r\n      const selection = window.getSelection();\r\n\r\n      // Evitar ocultar la barra si estamos interactuando con elementos de la barra\r\n      if (\r\n        toolbarRef.current &&\r\n        (toolbarRef.current.contains(document.activeElement) ||\r\n         (event && toolbarRef.current.contains(event.target)))\r\n      ) {\r\n        return;\r\n      }\r\n\r\n      // Evitar ocultar la barra si interactuamos con el menú de tamaño de fuente\r\n      if (\r\n        fontSizeMenuRef.current &&\r\n        (fontSizeMenuRef.current.contains(document.activeElement) ||\r\n         (selection.anchorNode && fontSizeMenuRef.current.contains(selection.anchorNode)))\r\n      ) {\r\n        return;\r\n      }\r\n      \r\n      // Verificar si el editor está activo\r\n      const isEditorActive = editorRef.current === document.activeElement;\r\n      \r\n      // Verificar si tenemos una selección válida\r\n      const hasSelection = selection && !selection.isCollapsed && editorRef.current;\r\n      \r\n      // Si ni el editor está activo ni hay selección, ocultar la barra\r\n      if (!isEditorActive && !hasSelection) {\r\n        setVisible(false);\r\n        setShowFontSizeMenu(false);\r\n        return;\r\n      }\r\n      \r\n      // Verificar si la selección o el cursor está dentro del editor\r\n      let isInEditor = false;\r\n      \r\n      if (isEditorActive) {\r\n        isInEditor = true;\r\n      } else if (hasSelection) {\r\n        const range = selection.getRangeAt(0);\r\n        let container = range.commonAncestorContainer;\r\n        \r\n        // Si el contenedor es un nodo de texto, obtener su elemento padre\r\n        if (container.nodeType === 3) {\r\n          container = container.parentNode;\r\n        }\r\n        \r\n        // Verificar si el contenedor o algún antecesor es el editor\r\n        let current = container;\r\n        \r\n        while (current && !isInEditor) {\r\n          if (current === editorRef.current) {\r\n            isInEditor = true;\r\n          }\r\n          current = current.parentNode;\r\n        }\r\n      }\r\n      \r\n      if (!isInEditor) {\r\n        setVisible(false);\r\n        setShowFontSizeMenu(false);\r\n        return;\r\n      }\r\n      \r\n      // Calcular la posición de la barra\r\n      const editorRect = editorRef.current.getBoundingClientRect();\r\n      \r\n      // Calculamos la altura de la barra\r\n      const toolbarHeight = toolbarRef.current ? toolbarRef.current.offsetHeight : 40;\r\n      const toolbarWidth = toolbarRef.current ? toolbarRef.current.offsetWidth : 200;\r\n      \r\n      let newPosition;\r\n      \r\n      if (hasSelection) {\r\n        // Si hay selección, posicionar debajo de la selección\r\n        const rect = selection.getRangeAt(0).getBoundingClientRect();\r\n        \r\n        if (rect.width === 0) {\r\n          setVisible(false);\r\n          setShowFontSizeMenu(false);\r\n          return;\r\n        }\r\n        \r\n        newPosition = {\r\n          // Posicionamos la barra DEBAJO de la línea de texto seleccionada\r\n          top: rect.bottom - editorRect.top + 8,\r\n          // Centramos horizontalmente respecto a la selección\r\n          left: rect.left - editorRect.left + (rect.width / 2)\r\n        };\r\n      } else {\r\n        // Si solo está activo el editor sin selección, posicionar debajo del cursor\r\n        try {\r\n          // Obtenemos la posición del cursor (caret)\r\n          const range = selection.getRangeAt(0);\r\n          \r\n          // Creamos un elemento temporal para medir la posición exacta del cursor\r\n          const span = document.createElement('span');\r\n          span.style.display = 'inline-block';\r\n          span.style.height = '0px';\r\n          span.style.width = '0px';\r\n          span.style.overflow = 'hidden';\r\n          span.innerHTML = '.'; // Necesitamos algún contenido para que tenga dimensiones\r\n          \r\n          // Guardamos una copia del rango para restaurarlo después\r\n          const rangeCopy = range.cloneRange();\r\n          \r\n          // Insertamos temporalmente el span en la posición del cursor\r\n          range.insertNode(span);\r\n          \r\n          // Obtenemos la posición del span (posición del cursor)\r\n          const spanRect = span.getBoundingClientRect();\r\n          \r\n          // Eliminamos el span temporal para no afectar al contenido\r\n          if (span.parentNode) {\r\n            span.parentNode.removeChild(span);\r\n          }\r\n          \r\n          // Restauramos la selección original\r\n          selection.removeAllRanges();\r\n          selection.addRange(rangeCopy);\r\n          \r\n          // Calculamos la posición de la barra basada en la posición del cursor\r\n          newPosition = {\r\n            // Posicionamos la barra justo debajo del cursor\r\n            top: spanRect.bottom - editorRect.top + 8, // Un pequeño margen debajo\r\n            // Alineamos horizontalmente con el cursor\r\n            left: spanRect.left - editorRect.left\r\n          };\r\n          \r\n          // Ajustes para que la barra no se salga de los límites del editor\r\n          if (newPosition.left < toolbarWidth / 2 + 10) {\r\n            newPosition.left = toolbarWidth / 2 + 10;\r\n          } else if (newPosition.left > editorRect.width - toolbarWidth / 2 - 10) {\r\n            newPosition.left = editorRect.width - toolbarWidth / 2 - 10;\r\n          }\r\n        } catch (error) {\r\n          // Si hay algún error, usamos una posición predeterminada segura\r\n          console.error('Error al obtener posición del cursor:', error);\r\n          newPosition = {\r\n            top: 50, // Posición vertical segura\r\n            left: editorRect.width / 2 // Centrado horizontalmente\r\n          };\r\n        }\r\n      }\r\n      \r\n      // Ajustar para que no se salga del editor\r\n      if (toolbarRef.current) {\r\n        // Ajuste horizontal para que no se salga por los lados\r\n        if (newPosition.left + (toolbarWidth / 2) > editorRect.width) {\r\n          newPosition.left = editorRect.width - (toolbarWidth / 2) - 10;\r\n        }\r\n        \r\n        if (newPosition.left - (toolbarWidth / 2) < 0) {\r\n          newPosition.left = (toolbarWidth / 2) + 10;\r\n        }\r\n        \r\n        // Si no hay espacio arriba, colocar debajo de la selección (para el caso de selección)\r\n        if (hasSelection && newPosition.top < 0) {\r\n          const rect = selection.getRangeAt(0).getBoundingClientRect();\r\n          newPosition.top = rect.bottom - editorRect.top + 8;\r\n        }\r\n      }\r\n      \r\n      setPosition(newPosition);\r\n      setVisible(true);\r\n      \r\n      // Guardar la selección actual para poder restaurarla más tarde\r\n      saveSelection();\r\n    } catch (error) {\r\n      console.error('Error al verificar selección:', error);\r\n      setVisible(false);\r\n      setShowFontSizeMenu(false);\r\n    }\r\n  };\r\n  \r\n  // ... [resto de funciones originales] ...\r\n  \r\n  // Modificar useEffect para eventos del editor\r\n  useEffect(() => {\r\n    // No agregar event listeners si no hay editorRef\r\n    if (!editorRef || !editorRef.current) return;\r\n    \r\n    document.addEventListener('selectionchange', checkSelection);\r\n    editorRef.current.addEventListener('mouseup', checkSelection);\r\n    editorRef.current.addEventListener('focus', checkSelection);\r\n    \r\n    // Añadir evento para detectar inicio de escritura\r\n    const handleKeyDown = (event) => {\r\n      // Solo reaccionamos a teclas \"normales\", no a atajos o teclas especiales\r\n      const isModifierKey = event.ctrlKey || event.metaKey || event.altKey;\r\n      const isNavigationKey = ['ArrowUp', 'ArrowDown', 'ArrowLeft', 'ArrowRight', 'Home', 'End', 'PageUp', 'PageDown'].includes(event.key);\r\n      \r\n      if (!isModifierKey && !isNavigationKey) {\r\n        handleTypingStart();\r\n      }\r\n    };\r\n    \r\n    // Ya no mostramos la barra en keyup\r\n    editorRef.current.addEventListener('keydown', handleKeyDown);\r\n    \r\n    // Limpiar event listeners\r\n    return () => {\r\n      document.removeEventListener('selectionchange', checkSelection);\r\n      if (editorRef.current) {\r\n        editorRef.current.removeEventListener('mouseup', checkSelection);\r\n        editorRef.current.removeEventListener('focus', checkSelection);\r\n        editorRef.current.removeEventListener('keydown', handleKeyDown);\r\n      }\r\n      \r\n      // Limpiar el timer si existe\r\n      if (typingTimerRef.current) {\r\n        clearTimeout(typingTimerRef.current);\r\n      }\r\n    };\r\n  }, [editorRef?.current, isTyping]);\r\n  \r\n  // ... [resto del código original] ...\r\n\r\n  return (\r\n    <div \r\n      ref={toolbarRef}\r\n      style={{\r\n        ...styles.floatingBar,\r\n        top: `${position.top}px`,\r\n        left: `${position.left}px`,\r\n        transform: 'translateX(-50%)' // Centrar horizontalmente respecto al punto de referencia\r\n      }}\r\n    >\r\n      {/* Resto del JSX original */}\r\n    </div>\r\n  );\r\n};\r\n\r\nexport default FloatingToolbar;"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}